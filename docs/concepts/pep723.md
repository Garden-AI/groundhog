# PEP 723 Metadata

Groundhog uses PEP 723 to embed configuration and dependencies directly in your Python scripts.

!!! admonition "So what?"
    Leaning into PEP 723 means that your code and its environment are defined in the **same file**. Tightly coupling the code-iteration loop to the environment-iteration loop means that you don't fix your code, then wait in the submission queue, then fix your hand-crafted virtual environment, then wait in the queue again, then realize your local environment doesn't match, etc etc. Just declare *what* and *where* your code needs to run, Groundhog takes care of the rest.

## What is PEP 723?

[PEP 723](https://peps.python.org/pep-0723/) defines a standard for inline script metadata (like a `pyproject.toml` for scripts). It allows Python scripts to declare:

- Python version requirements
- Package dependencies
- Tool-specific configuration

The metadata lives in a comment block at the top of your script:

```python
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "numpy",
#     "scipy>=1.11.0",
# ]
#
# [tool.hog.anvil]
# endpoint = "5aafb4c1-27b2-40d8-a038-a0277611868f"
# account = "my-account"
# ///

import groundhog_hpc as hog
# ... rest of your script
```

The `# ///` delimiters mark the start and end of the metadata block. Inside, you write TOML configuration.

## Why Inline Metadata?

PEP 723 solves a specific problem: standalone scripts need dependency information without requiring a `pyproject.toml` or complex project structure.

Before PEP 723, you had two bad options:

1. **Import and fail**: Write `import numpy` and let the script crash if numpy isn't installed
2. **Create a project**: Add `pyproject.toml`, virtual environment setup, and package tooling for a single script

PEP 723 provides a third option: declare dependencies inline. Tools like `uv` read the metadata and install packages automatically before running the script.

## How **`uv`** Uses PEP 723

When you run a script with `uv`:

```bash
uv run my_script.py
```

`uv` reads PEP 723 metadata (if present), creates an ephemeral virtual environment, and executes the script with the requested dependencies. **You don't need to manage any virtual environments yourself.**

## How Groundhog Uses PEP 723

Groundhog extends PEP 723 with HPC-specific configuration in `[tool.hog]` tables:

```python
# /// script
# requires-python = ">=3.12"
# dependencies = ["numpy"]
#
# [tool.hog.anvil]
# endpoint = "5aafb4c1-27b2-40d8-a038-a0277611868f"
# account = "my-account"
# walltime = "00:30:00"
# ///
```

When you call `.remote()`, Groundhog:

1. Reads your script's PEP 723 metadata
2. Templates a shell command that includes the metadata
3. Submits the command to your HPC cluster via Globus Compute
4. On the remote node, `uv` reads the metadata and sets up the environment
5. Your function executes in the configured environment

This ensures the remote environment exactly matches your script's requirements.

## Standard vs Tool-Specific Sections

PEP 723 defines standard fields:

- `requires-python` - Python version (e.g., `">=3.12,<3.13"`)
- `dependencies` - Package list (e.g., `["numpy", "scipy>=1.11"]`)

Tools can add their own sections under `[tool.*]`:

- `[tool.uv]` - uv-specific settings (e.g., `exclude-newer` for reproducibility)
- `[tool.hog.*]` - Groundhog endpoint configurations

Standard fields control the Python environment. Tool-specific fields configure behavior.

## Next Steps

- **[Dependencies Example](../examples/dependencies.md)** - Add and use packages
- **[Configuration Example](../examples/configuration.md)** - What else can `[tool.hog]` do?
- **[`uv` Scripts Guide](https://docs.astral.sh/uv/guides/scripts/)** - Complete `uv` documentation for PEP 723
